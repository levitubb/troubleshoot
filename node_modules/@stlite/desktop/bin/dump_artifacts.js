#!/usr/bin/env node
var O=Object.create;var h=Object.defineProperty;var P=Object.getOwnPropertyDescriptor;var $=Object.getOwnPropertyNames;var j=Object.getPrototypeOf,F=Object.prototype.hasOwnProperty;var g=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports);var x=(e,t,r,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of $(t))!F.call(e,o)&&o!==r&&h(e,o,{get:()=>t[o],enumerable:!(i=P(t,o))||i.enumerable});return e};var n=(e,t,r)=>(r=e!=null?O(j(e)):{},x(t||!e||!e.__esModule?h(r,"default",{value:e,enumerable:!0}):r,e));var w=g(u=>{"use strict";Object.defineProperty(u,"__esModule",{value:!0});u.parseRequirementsTxt=void 0;function C(e){return e.split(`
`).filter(t=>!t.startsWith("#")).map(t=>t.trim()).filter(t=>t!=="")}u.parseRequirementsTxt=C});var v=g(c=>{"use strict";var K=c&&c.__createBinding||(Object.create?function(e,t,r,i){i===void 0&&(i=r);var o=Object.getOwnPropertyDescriptor(t,r);(!o||("get"in o?!t.__esModule:o.writable||o.configurable))&&(o={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,i,o)}:function(e,t,r,i){i===void 0&&(i=r),e[i]=t[r]}),R=c&&c.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&K(t,e,r)};Object.defineProperty(c,"__esModule",{value:!0});R(w(),c)});var D=n(require("yargs")),b=require("yargs/helpers"),a=n(require("path")),s=n(require("fs/promises")),m=n(require("fs-extra")),f=n(require("node-fetch")),k=require("pyodide"),T=n(v());global.fetch=f.default;async function B(e){console.info("Copy the build directory (the bare built app files) to this directory...");let t=a.default.resolve(__dirname,"../build");if(!(await s.default.stat(t)).isDirectory())throw new Error(`The source ${t} does not exist.`);if(t===e.copyTo){console.warn(`sourceDir == destDir (${t}). Are you in the development environment? Skip copying the directory.`);return}if(e.keepOld)try{await s.default.access(e.copyTo),console.info(`${e.copyTo} already exists. Use it and skip copying.`);return}catch{throw new Error(`${e.copyTo} does not exist even though the \`keepOld\` option is specified`)}console.log(`Copy ${t} to ${e.copyTo}`),await s.default.rm(e.copyTo,{recursive:!0,force:!0}),await m.default.copy(t,e.copyTo)}async function _(e,t){console.log(`Install the local wheel ${t}`);let r=await s.default.readFile(t),i="/tmp/"+a.default.basename(t);e.FS.writeFile(i,r);let o=e.pyimport("micropip"),l=`emfs:${i}`;console.log(`Install ${l}`),await o.install.callKwargs(l,{keep_going:!0})}async function E(e){console.info("Create the site-packages snapshot file...");let t=await(0,k.loadPyodide)();if(await t.loadPackage(["micropip"]),e.useLocalKernelWheels){let l=a.default.dirname(require.resolve("@stlite/kernel")),p=a.default.resolve(l,"../py");await _(t,a.default.join(p,"stlite-server/dist/stlite_server-0.1.0-py3-none-any.whl")),await _(t,a.default.join(p,"streamlit/lib/dist/streamlit-1.21.0-py2.py3-none-any.whl"))}else{let p=require(a.default.resolve(__dirname,"../package.json")).version,S=`https://data.jsdelivr.com/v1/package/npm/@stlite/kernel@${p}/flat`,y=(await(await(0,f.default)(S)).json()).files.filter(d=>d.name.endsWith(".whl")).map(d=>`https://cdn.jsdelivr.net/npm/@stlite/kernel@${p}${d.name}`),q=t.pyimport("micropip");console.log("Install",y),await q.install.callKwargs(y,{keep_going:!0})}console.log(`Install the requirements ${JSON.stringify(e.requirements)}`),await t.pyimport("micropip").install.callKwargs(e.requirements,{keep_going:!0}),console.log("Archive the site-packages director(y|ies)");let i="/tmp/site-packages-snapshot.tar.gz";await t.runPythonAsync(`
    import tarfile
    import site

    site_packages_dirs = site.getsitepackages()

    tar_file_name = '${i}'
    with tarfile.open(tar_file_name, mode='w:gz') as gzf:
        for site_packages in site_packages_dirs:
            gzf.add(site_packages)
  `),console.log("Extract the archive file from EMFS");let o=t.FS.readFile(i);console.log(`Save the archive file (${e.saveTo})`),await s.default.writeFile(e.saveTo,o)}async function H(e){console.info("Copy the Streamlit app directory..."),console.log(`Copy ${e.sourceDir} to ${e.copyTo}`),await s.default.rm(e.copyTo,{recursive:!0,force:!0}),await m.default.copy(e.sourceDir,e.copyTo)}async function W(e){let t=await s.default.readFile(e,{encoding:"utf-8"});return(0,T.parseRequirementsTxt)(t)}function I(e){e.forEach(t=>{let r;try{r=new URL(t)}catch{return}if(r.protocol==="emfs:"||r.protocol==="file:")throw new Error(`"emfs:" and "file:" protocols are not allowed for the requirement (${t})`)})}(0,D.default)((0,b.hideBin)(process.argv)).command("* <appHomeDirSource> [packages..]","Put the user code and data and the snapshot of the required packages into the build artifact.",()=>{},e=>{console.info(e)}).positional("appHomeDirSource",{describe:"The source directory of the user code and data that will be mounted in the Pyodide file system at app runtime",type:"string",demandOption:!0}).positional("packages",{describe:"Package names to install.",type:"string",array:!0}).options("requirement",{describe:"Install from the given requirements file. This option can be used multiple times.",array:!0,type:"string",alias:"r",default:[]}).options("localKernelWheels",{describe:"Use the locally installed kernel wheels",type:"boolean",alias:"l",default:!1}).options("keepOldBuild",{type:"boolean",default:!1,alias:"k",describe:"Keep the existing build directory contents except appHomeDir."}).parseAsync().then(async e=>{let t=a.default.resolve(process.cwd(),"./build");try{await s.default.access(e.appHomeDirSource)}catch{throw new Error(`${e.appHomeDirSource} does not exist.`)}let r=e.packages;for(let i of e.requirement)r=r.concat(await W(i));I(r),await B({copyTo:t,keepOld:e.keepOldBuild}),await E({useLocalKernelWheels:e.localKernelWheels,requirements:r,saveTo:a.default.resolve(t,"./site-packages-snapshot.tar.gz")}),await H({sourceDir:e.appHomeDirSource,copyTo:a.default.resolve(t,"./streamlit_app")})});
